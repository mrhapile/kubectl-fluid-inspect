/*
Copyright 2026 kubectl-fluid-inspect Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package output

import (
	"archive/tar"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/mrhapile/kubectl-fluid-inspect/pkg/types"
)

// Archiver creates diagnostic archives
type Archiver struct {
	outputDir string
}

// NewArchiver creates a new Archiver
func NewArchiver() *Archiver {
	return &Archiver{
		outputDir: ".", // Current directory
	}
}

// CreateArchive creates a tar.gz archive of diagnostic data
func (a *Archiver) CreateArchive(result *types.DiagnosticResult) (string, error) {
	timestamp := time.Now().Format("20060102-150405")
	archiveName := fmt.Sprintf("fluid-diagnose-%s-%s.tar.gz", result.DatasetName, timestamp)
	archivePath := filepath.Join(a.outputDir, archiveName)

	// Create the archive file
	file, err := os.Create(archivePath)
	if err != nil {
		return "", fmt.Errorf("failed to create archive file: %w", err)
	}
	defer file.Close()

	// Create gzip writer
	gw := gzip.NewWriter(file)
	defer gw.Close()

	// Create tar writer
	tw := tar.NewWriter(gw)
	defer tw.Close()

	// Add files to archive

	// 1. dataset.yaml
	if err := a.addFileToTar(tw, "dataset.yaml", result.DatasetYAML); err != nil {
		return "", err
	}

	// 2. runtime.yaml (if exists)
	if result.RuntimeYAML != "" {
		if err := a.addFileToTar(tw, "runtime.yaml", result.RuntimeYAML); err != nil {
			return "", err
		}
	}

	// 3. events.log
	eventsContent := a.formatEvents(result.Events)
	if err := a.addFileToTar(tw, "events.log", eventsContent); err != nil {
		return "", err
	}

	// 4. resources.json
	resourcesJSON, _ := json.MarshalIndent(result.Resources, "", "  ")
	if err := a.addFileToTar(tw, "resources.json", string(resourcesJSON)); err != nil {
		return "", err
	}

	// 5. failure_hints.json
	hintsJSON, _ := json.MarshalIndent(result.FailureHints, "", "  ")
	if err := a.addFileToTar(tw, "failure_hints.json", string(hintsJSON)); err != nil {
		return "", err
	}

	// 6. pods/ directory with logs
	if result.Logs.Master != nil && result.Logs.Master.Logs != "" {
		if err := a.addFileToTar(tw, "pods/master.log", formatLogEntry(result.Logs.Master)); err != nil {
			return "", err
		}
	}

	for i, entry := range result.Logs.Workers {
		if entry.Logs != "" {
			filename := fmt.Sprintf("pods/worker-%d.log", i)
			if err := a.addFileToTar(tw, filename, formatLogEntry(&entry)); err != nil {
				return "", err
			}
		}
	}

	for i, entry := range result.Logs.Fuse {
		if entry.Logs != "" {
			filename := fmt.Sprintf("pods/fuse-%d.log", i)
			if err := a.addFileToTar(tw, filename, formatLogEntry(&entry)); err != nil {
				return "", err
			}
		}
	}

	// 7. summary.txt - Human readable summary
	summary := a.generateSummary(result)
	if err := a.addFileToTar(tw, "summary.txt", summary); err != nil {
		return "", err
	}

	// 8. context.json - AI-ready context
	diagnoser := &contextConverter{}
	context := diagnoser.ToContext(result)
	contextJSON, _ := json.MarshalIndent(context, "", "  ")
	if err := a.addFileToTar(tw, "context.json", string(contextJSON)); err != nil {
		return "", err
	}

	return archivePath, nil
}

// addFileToTar adds a file to the tar archive
func (a *Archiver) addFileToTar(tw *tar.Writer, name string, content string) error {
	header := &tar.Header{
		Name:    name,
		Mode:    0644,
		Size:    int64(len(content)),
		ModTime: time.Now(),
	}

	if err := tw.WriteHeader(header); err != nil {
		return fmt.Errorf("failed to write tar header for %s: %w", name, err)
	}

	if _, err := tw.Write([]byte(content)); err != nil {
		return fmt.Errorf("failed to write tar content for %s: %w", name, err)
	}

	return nil
}

// formatEvents formats events as a log file
func (a *Archiver) formatEvents(events []types.EventInfo) string {
	var sb strings.Builder
	sb.WriteString("# Kubernetes Events\n")
	sb.WriteString("# Generated by kubectl-fluid-inspect\n")
	sb.WriteString("#\n\n")

	for _, event := range events {
		sb.WriteString(fmt.Sprintf("[%s] %s %s/%s: %s\n",
			event.LastTimestamp.Format("2006-01-02 15:04:05"),
			event.Type,
			event.ObjectKind,
			event.ObjectName,
			event.Reason))
		sb.WriteString(fmt.Sprintf("    %s\n\n", event.Message))
	}

	return sb.String()
}

// generateSummary generates a human-readable summary
func (a *Archiver) generateSummary(result *types.DiagnosticResult) string {
	var sb strings.Builder

	sb.WriteString("FLUID DATASET DIAGNOSTIC SUMMARY\n")
	sb.WriteString("================================\n\n")

	sb.WriteString(fmt.Sprintf("Dataset:      %s\n", result.DatasetName))
	sb.WriteString(fmt.Sprintf("Namespace:    %s\n", result.Namespace))
	sb.WriteString(fmt.Sprintf("Collected At: %s\n", result.CollectedAt.Format("2006-01-02 15:04:05")))
	sb.WriteString(fmt.Sprintf("Health:       %s\n", result.HealthStatus))
	sb.WriteString("\n")

	sb.WriteString("RESOURCE STATUS\n")
	sb.WriteString("---------------\n")

	if result.Resources.Master != nil {
		sb.WriteString(fmt.Sprintf("Master:  %d/%d ready\n",
			result.Resources.Master.Ready,
			result.Resources.Master.Desired))
	}
	if result.Resources.Workers != nil {
		sb.WriteString(fmt.Sprintf("Workers: %d/%d ready\n",
			result.Resources.Workers.Ready,
			result.Resources.Workers.Desired))
	}
	if result.Resources.Fuse != nil {
		sb.WriteString(fmt.Sprintf("Fuse:    %d/%d ready\n",
			result.Resources.Fuse.Ready,
			result.Resources.Fuse.Desired))
	}
	if result.Resources.PVC != nil {
		sb.WriteString(fmt.Sprintf("PVC:     %s\n", result.Resources.PVC.Phase))
	}
	sb.WriteString("\n")

	if len(result.FailureHints) > 0 {
		sb.WriteString("DETECTED ISSUES\n")
		sb.WriteString("---------------\n")
		for _, hint := range result.FailureHints {
			sb.WriteString(fmt.Sprintf("[%s] %s: %s\n",
				strings.ToUpper(hint.Severity),
				hint.Component,
				hint.Issue))
			sb.WriteString(fmt.Sprintf("  -> %s\n", hint.Suggestion))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("ARCHIVE CONTENTS\n")
	sb.WriteString("----------------\n")
	sb.WriteString("- dataset.yaml:       Dataset CR snapshot\n")
	sb.WriteString("- runtime.yaml:       Runtime CR snapshot\n")
	sb.WriteString("- events.log:         Kubernetes events\n")
	sb.WriteString("- resources.json:     Resource status details\n")
	sb.WriteString("- failure_hints.json: Detected issues\n")
	sb.WriteString("- pods/               Container logs\n")
	sb.WriteString("- context.json:       AI-ready diagnostic context\n")
	sb.WriteString("\n")

	sb.WriteString("----------\n")
	sb.WriteString("Generated by kubectl-fluid-inspect\n")

	return sb.String()
}

// Helper functions

func formatLogEntry(entry *types.LogEntry) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# Pod: %s\n", entry.PodName))
	sb.WriteString(fmt.Sprintf("# Container: %s\n", entry.ContainerName))
	sb.WriteString(fmt.Sprintf("# Tail Lines: %d\n", entry.TailLines))
	if entry.Error != "" {
		sb.WriteString(fmt.Sprintf("# Error: %s\n", entry.Error))
	}
	sb.WriteString("#\n\n")
	sb.WriteString(entry.Logs)
	return sb.String()
}

// contextConverter helps convert DiagnosticResult to DiagnosticContext
type contextConverter struct{}

func (c *contextConverter) ToContext(result *types.DiagnosticResult) *types.DiagnosticContext {
	ctx := &types.DiagnosticContext{
		DatasetYAML:  result.DatasetYAML,
		RuntimeYAML:  result.RuntimeYAML,
		Events:       result.Events,
		FailureHints: result.FailureHints,
		CollectedAt:  result.CollectedAt,
		Version:      "1.0",
		Logs:         make(map[string]string),
	}

	// Build summary
	ctx.Summary = types.ContextSummary{
		DatasetName:  result.DatasetName,
		Namespace:    result.Namespace,
		DatasetPhase: extractPhaseFromDiagnostic(result),
		RuntimeType:  result.RuntimeType,
		HealthStatus: result.HealthStatus,
	}

	// Add resource status to summary
	if result.Resources.Master != nil {
		ctx.Summary.MasterReady = fmt.Sprintf("%d/%d", result.Resources.Master.Ready, result.Resources.Master.Desired)
	}
	if result.Resources.Workers != nil {
		ctx.Summary.WorkersReady = fmt.Sprintf("%d/%d", result.Resources.Workers.Ready, result.Resources.Workers.Desired)
	}
	if result.Resources.Fuse != nil {
		ctx.Summary.FuseReady = fmt.Sprintf("%d/%d", result.Resources.Fuse.Ready, result.Resources.Fuse.Desired)
	}
	if result.Resources.PVC != nil {
		ctx.Summary.PVCStatus = result.Resources.PVC.Phase
	}

	// Count events
	for _, event := range result.Events {
		if event.Type == "Warning" {
			ctx.Summary.WarningCount++
		}
	}
	ctx.Summary.ErrorCount = len(result.FailureHints)

	// Add logs
	if result.Logs.Master != nil && result.Logs.Master.Logs != "" {
		ctx.Logs["master"] = result.Logs.Master.Logs
	}
	for i, entry := range result.Logs.Workers {
		if entry.Logs != "" {
			key := fmt.Sprintf("worker-%d", i)
			ctx.Logs[key] = entry.Logs
		}
	}
	for i, entry := range result.Logs.Fuse {
		if entry.Logs != "" {
			key := fmt.Sprintf("fuse-%d", i)
			ctx.Logs[key] = entry.Logs
		}
	}

	return ctx
}
